# ADR-003: Використати JWT для автентифікації та управління сесіями

## Статус
Прийнято

## Контекст
Застосунок для відстеження витрат потребує безпечної та масштабованої системи автентифікації.  
Основні вимоги:  
- Захист користувацьких паролів від компрометації  
- Безпечна передача даних між клієнтом і сервером  
- Масштабованість у розподіленому середовищі (Kubernetes, кілька інстансів API)  
- Зручність для користувачів (мінімізація повторних входів)

## Рішення
Реалізувати автентифікацію на основі **JWT-токенів**:  
- **Паролі** зберігати у БД лише у вигляді хешів (`bcrypt` із сіллю та work factor ≥ 10).  
- **Клієнтський логін**: `POST /auth/login` передає креденшали по HTTPS.  
- **API** після валідації повертає два токени:  
  - **Access Token** (короткочасний, 15 хв)  
  - **Refresh Token** (довгочасний, 7–30 днів, зберігається у захищеному сховищі)  
- Клієнт надсилає всі подальші запити з `Authorization: Bearer <access_token>`.  
- Refresh-токени зберігаються у БД / Redis для відкликання.  
- Вся комунікація відбувається через HTTPS (TLS 1.2+).  

## Наслідки
- ✅ Масштабування без необхідності sticky sessions у балансувальнику  
- ✅ Сучасний стандарт, сумісний із веб- і мобільними клієнтами  
- ✅ Захист паролів через bcrypt  
- ✅ Підтримка session timeout та механізму відкликання токенів  
- ⚠️ Потрібна інфраструктура для керування refresh-токенами (наприклад, Redis)  
- ⚠️ У разі компрометації access-токен діятиме до закінчення свого TTL  
- ❌ Ускладнене управління безпекою у порівнянні зі звичайними сесіями

## Реалізація
Спринт 2: Додати модуль Auth у backend, реалізувати логіку логіну та генерації токенів  
Спринт 2: Інтегрувати Redis / PostgreSQL для зберігання refresh-токенів  
Спринт 2: Реалізувати middleware для перевірки access-токенів у кожному API-виклику  
Спринт 2: Налаштувати ротацію та відкликання токенів, додати тестування безпеки
