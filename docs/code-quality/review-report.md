## Оцінка за критеріями

W - wery good.
! - треба звернути увагу/допрацювати.

### 1. Стиль та стандарти кодування

- W Код відформатовано за допомогою `gofmt` та `goimports` – всі файли Go дотримуються стандартного стилю форматування Go   [go.dev](https://go.dev/doc/effective_go#:~:text=With%20Go%20we%20take%20an,don%27t%20work%20around%20it).
- W Імена пакетів і змінних відповідають конвенціям Go: пакети – у нижньому регістрі (без знаків підкреслення), типи та експортовані поля – у змішаній CamelCase (MixedCaps)[go.dev](https://go.dev/doc/effective_go#:~:text=MixedCaps).
- W У TypeScript-фронтенді увімкнено суворі налаштування компілятора (`strict`), відсутні невикористані змінні та параметри, що сприяє чистоті коду. Налаштовано ESLint з рекомендаційними правилами для React/TypeScript.
- ! Декілька файлів Go містять невикористані імпорти (`fmt` у `app.go`, `log` у багатьох хендлерах) – це не відповідає правилам Go (unused imports зазвичай викидаються `go fmt` або `golangci-lint`). Слід видалити зайві імпорти чи використовувати їх належно.
- ! В коді Go додатково використовується `log.Println` чи `fmt.Printf` для виводу помилок у замість структурованого логера `zap`. Для єдності варто використовувати один механізм логування (рекомендується `zap`) замість міксування з `log`/`fmt`.

### 2. Якість та підтримуваність

- W Чітке розділення логіки на шари: HTTP-обробники (handler) викликають сервіси, сервіси працюють з репозиторіями бази. Така архітектура (Controller → Service → Repository).
- W Наявність обгортки `ApiClient` на фронтенді із централізованою обробкою HTTP-запитів та конфігурація базової URL.
- ! Відсутні юніт-тести та інтеграційні тести для коду (ані у бекенді, ані у фронтенді). Рішення бізнес-логіки не покрито тестами – ризик регресій при модифікаціях.
- ! Дублікація коду: багато CRUD-хендлерів та методів сервісів схожі між собою (document, group, user), що ускладнює підтримку. Можна розглянути шаблонні підходи (дженерики Go, автоматичну генерацію коду чи узагальнені утиліти) для зменшення повторень.
- ! У налаштуванні Docker та `docker-compose` відсутня перевірка CORS (можливо, на стороні сервера Gin немає middleware для обробки CORS). Без нього браузер може блокувати запити з іншого походження (наприклад, Vite-сервер). Рішення: додати налаштування `cors` (наприклад, через `github.com/gin-contrib/cors`) для безпечної роботи клієнта.
### 3. Безпека

- W Використовується `ozzo-validation` для валідації основних полів запитів (наприклад, `CreateDocumentRequest.Validate()`), що запобігає некоректним або порожнім вхідним даним і робить API більш стійким до простих помилок.
    
- ! Пароль зберігається у відкритому вигляді. У реєстрації (`RegRepository.Register`) хешування пароля (`hashed_password`) не виконується – сам пароль записується у БД. Це серйозна уразливість: якщо базу скомпрометовано, зловмисник отримає всі паролі[snyk.io](https://snyk.io/blog/secure-password-hashing-in-go/#:~:text=The%20difference%20between%20hashing%20and,hashing%20is%20the%20recommended%20approach). Рішення: при реєстрації застосувати безпечне хешування пароля (bcrypt, Argon2 тощо) перед записом у БД[snyk.io](https://snyk.io/blog/secure-password-hashing-in-go/#:~:text=The%20difference%20between%20hashing%20and,hashing%20is%20the%20recommended%20approach).
- ! Відсутність аутентифікації. Немає endpoint’ів для логіну/JWT-токенів, тому всі API-доступні відкрито. Потрібно додати механізм аутентифікації (наприклад, JWT) та відповідні middleware у Gin, аби захистити приватні маршрути.
- ! Ризик XSS при рендерингу Markdown. Якщо на фронтенді використовується `dangerouslySetInnerHTML` для контенту Markdown без попередньої санітизації, це може призвести до XSS-атак (зловмисник може інжектнути скрипт через вхідний Markdown)[invicti.com](https://www.invicti.com/blog/web-security/is-react-vulnerable-to-xss/#:~:text=Example%201%3A%20Using%20unsanitized%20Markdown). Рішення: застосувати бібліотеку для безпечного рендерингу Markdown (з опцією sanitize) або вручну видаляти небезпечні теги.
    
- ! Додатково: перевірка прав доступу (ACL) до документів/груп наразі не реалізована. За поточної моделі будь-який користувач може змінювати будь-який документ. Варто передбачити механізм прив’язки документів до користувачів чи груп і перевіряти права.
    

### 4. Використання фреймворків

- W Використано сучасні фреймворки та бібліотеки: `Gin` для API (літніший проект) і `Go модулі` – це забезпечує швидкий стартап сервера. Бібліотека `uuid` використовується для унікальних ідентифікаторів, `envconfig` – для зручного читання конфігурації з .env.
- W На фронтенді застосовано `React 19` з TypeScript, `Vite` як збирач, а також `Material-UI` (MUI) та `Emotion` для оформлення. Використання React Context для темізації (`ThemeProvider`) та локалізації (`LanguageContext`) свідчить про адаптивність дизайну та підтримку i18n.
- W Налагоджено Swagger-документацію: коментарі `@Summary`, `@Router` у коді дозволяють згенерувати OpenAPI spec через swaggo. Документація API легко доступна розробникам.
- ! У деяких сервісах застосовано анонімні структури замість чітких DTO. Наприклад, у статистиці документації можна створити окремий `StatisticsDto` для ясності та автогенерації Swagger.
- ! На фронтенді не всі сучасні можливості використані: наприклад, можна підключити бібліотеку для опрацювання Markdown (якщо вона планується).

### 5. Документація та статичний аналіз

- W Проєкт містить добре оформлений `README.md`: опис цілей (Markdown Circus Docs), перелік учасників з контактами, інструкції для запуску (вимагає Go та Node.js). Також є `TeamChapter.md` з ролями команди.
- W Є Docker Compose та Taskfile для спрощеного запуску середовища (наприклад, `task: copy:env`, `task db:migrate:up`, запуск сервера). Це робить проект швидким до підійому.
- W Налаштовано `GitHub Actions`: є робота `lint` для статичного аналізу Go (go-task, golangci-lint) і `unit-tests` (хоча тестів немає, але структура CI є). Також автоматичний деплой Swagger Docs при пуші в main.
- ! Не налаштовано `ESLint/Prettier` у CI для фронтенду. На даний момент перевіряються тільки Go-код і тести Go. Цілком слушно додати лінтинг та форматування TS-коду (наприклад, як CI job з `npm run lint`)[graphite.dev](https://graphite.dev/guides/best-practices-integrating-static-analysis-pull-requests#:~:text=Why%20integrate%20static%20analysis%20into,pull%20requests), щоб забезпечити сталий стиль коду і уникнути помилок.
- ! В коді бракує детальних коментарів: хоча є Swagger-коментарі для API, не вистачає GoDoc над сутностями сервісів/репозиторіїв і TypeScript описів інтерфейсів. Також відсутні засоби для статичного аналізу (типу Coveralls, SonarQube) та функціональних тестів у CI.

---

## 3 позитивні аспекти

1. Чітке розділення обов’язків: Код структурований за шарами (handlers → services → repositories). Це підвищує модульність і тестованість коду. Контейнеризація з Docker Compose дозволяє легко запускати проект одним набором команд.
2. Сучасний стек технологій: Використано останні версії (Go 1.25, React 19 з TypeScript). Бібліотеки та фреймворки (Gin, Material UI, Ozzo Validation, Swagger) застосовані грамотно. В коді видно розуміння та дотримання стандартів розробки на цих платформах.
3. Документація та CI: Наявний повноцінний README з інструкціями запуску, ролі учасників у документації. Застосовано Swagger для API-документації, що полегшує розробку клієнтів. CI для бекенду вже налаштований – запускається лінт і міграції.
    

---

## 3 пропозиції покращення

1. Безпечне зберігання паролів: Замість збереження пароля у відкритому вигляді, слід використати bcrypt/Argon2 для хешування перед збереженням у БД. Також варто реалізувати механізм аутентифікації (login) з видачею JWT, щоби обмежити доступ до приватних ендпоінтів.
2. CI та тести: Додати юніт- та інтеграційні тести (наприклад, для сервісів бекенду). У CI GitHub Actions розширити тестування: запустити ESLint/Prettier для фронтенду та тестовий фреймворк (Jest, Testing Library) для React. Це забезпечить підтримку якості коду і виявлення помилок на ранніх стадіях[graphite.dev](https://graphite.dev/guides/best-practices-integrating-static-analysis-pull-requests#:~:text=Why%20integrate%20static%20analysis%20into,pull%20requests).
3. Логування та валідація: Узгодити підхід до логування: використовувати `zap` у всьому коді замість перехідних `log.Println`. Переглянути обробку помилок – можливо, створити окремі типи помилок (не лише `ErrInternal`) для кращого розмежування. Для фронтенду – додати санітизацію Markdown (наприклад, використати `DOMPurify`), щоб захиститися від можливих XSS-атаk.
    

---

> Потенційна уразливість:
> Пароль зберігається у відкритому вигляді. У моделі User пароль передається в БД без хешування. Це означає, що при будь-якій витоку БД всі паролі стануть доступними зловмиснику. Рекомендація: хешувати пароль перед збереженням (наприклад, bcrypt) і повертати в API лише хешовану чи ні – найкраще взагалі не повертати його з API.

---

## Загальний висновок

Якість коду – Середня. Архітектура проєкту побудована правильно із чітким розподілом шарів, код у цілому чистий та зрозумілий. Проєкт використовує сучасні технології та має достатню документацію. Основні зони для удосконалення – це безпека (хешування паролів, додавання аутентифікації), покращення тестового покриття та налаштування статичного аналізу для фронтенду. При виправленні зазначених моментів якість можна буде визнати високою.

## Отриманий висновок від іншої команди

Поки що відсутній (оновиться, коли з’явиться).